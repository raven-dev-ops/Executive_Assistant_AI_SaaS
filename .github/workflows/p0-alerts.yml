name: P0 Alert Checks

on:
  workflow_dispatch:
  schedule:
    - cron: "*/15 * * * *"  # every 15 minutes

permissions:
  contents: read
  id-token: write

jobs:
  p0-alerts:
    runs-on: ubuntu-latest
    steps:
      - name: Compute metrics audience (Cloud Run base URL)
        id: metrics
        env:
          METRICS_URL: ${{ secrets.METRICS_URL }}
          UPTIME_BASE_URL: ${{ secrets.UPTIME_BASE_URL }}
        run: |
          python - <<'PY'
          import os
          from urllib.parse import urlsplit

          metrics_url = (os.getenv("METRICS_URL") or "").strip()
          uptime_base = (os.getenv("UPTIME_BASE_URL") or "").strip().rstrip("/")
          if not metrics_url and uptime_base:
              metrics_url = f"{uptime_base}/metrics/prometheus"

          audience = ""
          if metrics_url:
              parts = urlsplit(metrics_url)
              audience = f"{parts.scheme}://{parts.netloc}"

          out = os.environ.get("GITHUB_OUTPUT")
          if out:
              with open(out, "a", encoding="utf-8") as fh:
                  fh.write(f"metrics_url={metrics_url}\n")
                  fh.write(f"audience={audience}\n")

          print(f"metrics_url={metrics_url}")
          print(f"audience={audience}")
          PY

      - name: Authenticate to Google Cloud (OIDC, optional)
        id: gcp-auth
        if: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER != '' && secrets.GCP_SERVICE_ACCOUNT != '' && steps.metrics.outputs.audience != '' }}
        uses: google-github-actions/auth@v2
        with:
          token_format: id_token
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          audience: ${{ steps.metrics.outputs.audience }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Run P0 alert checks
        env:
          METRICS_URL: ${{ secrets.METRICS_URL }} # e.g., https://.../metrics/prometheus
          METRICS_AUTH_HEADER: ${{ secrets.METRICS_AUTH_HEADER }} # e.g., Authorization: Bearer xxx
          METRICS_ID_TOKEN: ${{ steps.gcp-auth.outputs.id_token }} # optional (Cloud Run auth via OIDC)
          UPTIME_BASE_URL: ${{ secrets.UPTIME_BASE_URL }} # optional fallback (used by uptime checks workflow)
          TWILIO_WEBHOOK_THRESHOLD: ${{ secrets.TWILIO_WEBHOOK_THRESHOLD }} # legacy
          CALENDAR_FAILURE_THRESHOLD: ${{ secrets.CALENDAR_FAILURE_THRESHOLD }} # legacy
          AUTH_FAILURE_THRESHOLD: ${{ secrets.AUTH_FAILURE_THRESHOLD }} # legacy
          OWNER_ALERT_FAILURE_THRESHOLD: ${{ secrets.OWNER_ALERT_FAILURE_THRESHOLD }} # legacy
          TWILIO_WEBHOOK_FAILURES_THRESHOLD: ${{ secrets.TWILIO_WEBHOOK_FAILURES_THRESHOLD }}
          CALENDAR_WEBHOOK_FAILURES_THRESHOLD: ${{ secrets.CALENDAR_WEBHOOK_FAILURES_THRESHOLD }}
          STRIPE_WEBHOOK_FAILURES_THRESHOLD: ${{ secrets.STRIPE_WEBHOOK_FAILURES_THRESHOLD }}
          TOTAL_ERRORS_THRESHOLD: ${{ secrets.TOTAL_ERRORS_THRESHOLD }}
          ALERTS_OPEN_THRESHOLD: ${{ secrets.ALERTS_OPEN_THRESHOLD }}
          CHAT_P95_MS_THRESHOLD: ${{ secrets.CHAT_P95_MS_THRESHOLD }}
          CONVERSATION_P95_MS_THRESHOLD: ${{ secrets.CONVERSATION_P95_MS_THRESHOLD }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }} # optional
        run: |
          python - <<'PY'
          import os
          import sys
          import json
          import requests

          metrics_url = (os.getenv("METRICS_URL") or "").strip()
          uptime_base = (os.getenv("UPTIME_BASE_URL") or "").strip().rstrip("/")
          if not metrics_url and uptime_base:
              metrics_url = f"{uptime_base}/metrics/prometheus"
          hdr_raw = os.getenv("METRICS_AUTH_HEADER")
          id_token = (os.getenv("METRICS_ID_TOKEN") or "").strip()
          headers = {}
          if hdr_raw and ":" in hdr_raw:
              k, v = hdr_raw.split(":", 1)
              headers[k.strip()] = v.strip()
          elif id_token:
              headers["Authorization"] = f"Bearer {id_token}"

          def _f(name: str, default: float) -> float:
              raw = os.getenv(name)
              if raw is None or str(raw).strip() == "":
                  return default
              try:
                  return float(raw)
              except Exception:
                  return default

          thresholds = {
              "ai_telephony_twilio_webhook_failures": _f(
                  "TWILIO_WEBHOOK_FAILURES_THRESHOLD",
                  _f("TWILIO_WEBHOOK_THRESHOLD", 0.0),
              ),
              "ai_telephony_calendar_webhook_failures": _f(
                  "CALENDAR_WEBHOOK_FAILURES_THRESHOLD",
                  _f("CALENDAR_FAILURE_THRESHOLD", 0.0),
              ),
              "ai_telephony_billing_webhook_failures": _f(
                  "STRIPE_WEBHOOK_FAILURES_THRESHOLD", 0.0
              ),
              "ai_telephony_total_errors": _f(
                  "TOTAL_ERRORS_THRESHOLD",
                  _f("AUTH_FAILURE_THRESHOLD", 0.0),
              ),
              "ai_telephony_alerts_open": _f(
                  "ALERTS_OPEN_THRESHOLD",
                  _f("OWNER_ALERT_FAILURE_THRESHOLD", 0.0),
              ),
              "ai_telephony_chat_latency_p95_ms": _f("CHAT_P95_MS_THRESHOLD", 2000.0),
              "ai_telephony_conversation_latency_p95_ms": _f(
                  "CONVERSATION_P95_MS_THRESHOLD", 4000.0
              ),
          }

          def parse_metric(text: str, name: str) -> float | None:
              for line in text.splitlines():
                  line = line.strip()
                  if not line or line.startswith("#"):
                      continue
                  if line.startswith(name + "{") or line.startswith(name + " "):
                      try:
                          value = float(line.split()[-1])
                          return value
                      except Exception:
                          continue
              return None

          findings = []
          if not metrics_url:
              print("METRICS_URL not set; skipping.")
          else:
              try:
                  resp = requests.get(metrics_url, headers=headers, timeout=10)
                  if resp.status_code != 200:
                      # If metrics are behind auth and no auth header is configured, avoid
                      # noisy scheduled failures. Operators should configure either:
                      # - a reachable public metrics endpoint, OR
                      # - METRICS_AUTH_HEADER (or future WIF-based auth).
                      if not headers and resp.status_code in (401, 403, 404):
                          print(
                              "Metrics check skipped: "
                              f"GET {metrics_url} -> {resp.status_code} and METRICS_AUTH_HEADER is not configured."
                          )
                          print(
                              "To enable P0 checks, set METRICS_URL to a reachable /metrics/prometheus endpoint "
                              "or configure METRICS_AUTH_HEADER."
                          )
                          sys.exit(0)
                      raise RuntimeError(
                          f"GET {metrics_url} -> {resp.status_code}: {resp.text[:200]}"
                      )
                  text = resp.text
                  for metric, threshold in thresholds.items():
                      val = parse_metric(text, metric)
                      if val is None:
                          continue
                      if val > threshold:
                          findings.append(f"{metric}={val} > {threshold}")
              except Exception as exc:
                  findings.append(f"metrics_fetch_failed: {exc}")

          if findings:
              msg = "P0 alert conditions met: " + "; ".join(findings)
              print(msg)
              slack_webhook = os.getenv("SLACK_WEBHOOK")
              if slack_webhook:
                  try:
                      requests.post(
                          slack_webhook,
                          headers={"Content-Type": "application/json"},
                          data=json.dumps({"text": msg}),
                          timeout=5,
                      )
                  except Exception as exc:
                      print(f"Slack notify failed: {exc}", file=sys.stderr)
              sys.exit(1)

          print("P0 checks passed.")
          PY
